## ■ 開発環境に関して
 
node.jsはインストールしておこう。
npm install eslint
でESLintを入れる。

プロジェクトフォルダで、node init を実行するとpackages.jsonファイルが生成される。
~~~
npx eslint --init
~~~
で初期化しておくと、eslintを使ってスクリプトの文法チェックしてくれる。
VSCodeの拡張機能にもeslintを使ったチェック処理があるみたいなので、いれとくと便利。

## ■ ドキュメントについて

MDN web docsを参照。
https://developer.mozilla.org/ja/docs/Web/JavaScript

## ■ 言語に関して

### __メンバ変数の名前で、先頭にアンダースコア('_')がついてる場合__

    変数の先頭にアンダースコア'_'ついてるのはprivateメンバという意味合いになる。
    外のオブジェクトから参照しちゃダメよ。
    ついてないやつはオッケー。
    曖昧な等価判定は==、厳密な等価判定は===ってこと。
    型変換して試す分、==の方がコストかかる．．．と想像される。

### ...って何？

...array とか。Math.maxの引数で使われていたりする。
これはArrayの展開表現になる。
例えば
~~~javascript
    const array = [1, 2, 3, 4, 5];
    console.log(...array);
~~~

とすると、"1 2 3 4 5"と出力される。


### __==と===__

    ==は型変換して一致してもオッケー。
    ===は型変換なしで一致するとオッケー。

### __prototypekキーワード__

    自身のベースクラスみたいな概念。クラスはないのでインスタンスか。

### __constructorキーワード__

    インスタンスを生成するためのスペシャルメソッドを指すキーワード
    scene.constructorとかは、sceneオブジェクトを生成するためのコンストラクタを挿す。

### __配列とディクショナリ(連想配列)__

    小さい文字だとわかりにくいけど、括弧が配列、中括弧が連想配列。

#### 配列

~~~javascript
        const array = [ 1, 2, 3 ];
~~~

|操作|記述|
|---|---|
|要素数|array.length|
|要素|array[インデックス]
|逐次処理|array.forEach(function(arg) { /* TODO */ });|
||for (const variable of array) { /* TODO */ }|
|末尾追加|array.push(any);|
|末尾削除|array.pop();|
|先頭挿入|array.unshift(any);|
|先頭削除|array.shift();|
|インデックス取得|array.indexOf(any);|
|所定位置(pos)からn個削除|array.splice(pos, n);|
|特定の場所に挿入|array.splice(pos, 0, item)|

　
　
#### 連想配列(キーと値のペア持つ、いわゆるDictionary形式) 

~~~javascript
      const dictionary = { 'key':value };
~~~

|操作|記述|
|---|---|
|要素|dictionary[キー]|
|要素設定/追加|dictionary[キー] = 値|
|要素削除|delete dictionary[キー]|

### __Number__

  数値のラッパークラス。
  numberとは異なり、Numberからnumberへの変換は
  Number.number()で生成するらしい。

### __bind()__

    メソッド.bind(オブジェクト)

という書き方をして使う。オブジェクトにバインドされたメソッドが返る。
返ったメソッドをコールすると、thisキーワードが指定したオブジェクトを指すようになる。
わかりにくい！
ハンドラを登録するとき、呼び出し元にオブジェクトを渡すために使うのだ。
例えば

    hoge.setHandler(this.method1);

とすると、hogeオブジェクトがハンドラを呼び出した際、
method1に渡るthisはhogeオブジェクトになる。
一方

    hoge.setHandler(this.method1.bind(this))

とすると、hogeオブジェクトがハンドラを呼び出した際、
method1に渡るthisはbindで渡したthisになる。
  
つ・ま・り、オブジェクトのメンバメソッドをコールバック登録したいときは、
bind(this)しとけということ。

### __代入のところにある||演算子__

    hoge = hoge || 97

のような記述がある。これはメソッドの中でだけ使用できて、hogeが未定義なら97が代入されるというもの。デフォルト引数みたいなもんだ。
正確には

     hoge = undefined || 97

という判定になって、97が返るという仕組みだな。

JSはオブジェクトに関数を持たせられるが、実際は関数(function)と
必ずデータ(this)がセットになるという理解の方がよい。
thisキーワードは通常'.'の前にあるオブジェクトが渡るが、
callやapplyというのがあるので絶対ではない。

~~~
  <funciton>.call(obj, arg1, ...) 
~~~

\<function\>を実行するが、thisをobjで指定したものに置き換えて実行する。
~~~
  <function>.apply(obj, args)
~~~
基本的にはcallと同様。但し\<function\>の引数の渡し方が配列指定になる。



### __コンストラクタの書き方__

コンストラクタの書き方はグローバル汚染とかいろいろあって
以下のように記述するのが通例になっているようだ。
~~~javascript
  function ClassName() {
      this.initialize.apply(this, arguments);
  }
~~~
すると定義されたinitializeが呼び出されてうまくいくという仕組みなんだが。
initializeってどうやって定義しとるんか。
~~~javascript
  ClassName.prototype.initialize = function(arg1, arg2, ...) {
       // ここに初期化コードを書く
  } 
~~~

という形で定義している。
シェルスクリプトだと実行するところの後に定義を書いたりするとエラーになったりするけれど、
JSはなさそうだなあ。
ここでのポイントはprotptypeが親オブジェクトを指しているということ。
ClassName.initialize = function()って書かないのが何でなのかさっぱりわからん。

### __クラスの派生と継承__

~~~javascript
  function 派生クラス() {
       this.initialize.apply(this, arguments);
  }

  派生クラス.prototype = Object.create(基底クラス.prototype);
  派生クラス.prototype.constructor = 派生クラス
~~~

派生クラス.prototype = Object.create(基本クラス.prototype)
とすることで、基底クラスのすべてのメンバを受け継ぐ。
詳しくはprototypeキーワードで調べよ。

### 設計時での推奨点

ベースクラスのメンバを直接書き換えることはしない。
可能な限りメソッドを使おう。

### __名前空間？__

~~~javascript
  hoge = hoge || {};
~~~
みたいな書き方しているのは名前空間の作成。
実際にはメンバ変数持てるラッパーオブジェクトの構築なんだが。
うまいこと名前がかぶらないようにしてる。

他の名前空間のオブジェクトへの参照が少ないものが、
バグを減らす一つのポイントになる。
  
### __正規表現マッチング??

ノートタグの解析で使用する事が多い。
正規表現はスラッシュ('/')で囲んだものをパターンとしてマッチングに使用できる。
例
~~~javascript
     const pattern = /<BasicParam (\d+) (\d+) (\d+) (\d+) (\d+) (\d+)>/;
~~~

上記を文字列に適用するには、String.match(pattern)を使用する。
~~~javascript
     const str = "<BasicParam 1 2 3 4 5 6>";
     const match = str.match(pattern);
     if (match) {

     }
~~~

引数を取り出すなら、match[1]などとしてアクセスする。

~~~javascript
         match[1] // 上記の例だと、"1"が返る。
~~~

あるいは、match()を呼ぶことで、RegExグローバルオブジェクトにパラメータが格納される。
RegExp.$1, RegExp.$2などのメンバに、マッチした文字列が格納される。

スラッシュ('/')とスラッシュ('/')の後に記載されたアルファベットには意味がある。

|文字|意味|
|---|---|
|g|グローバルサーチ|
|i|大文字と小文字を無視する。|
|m|複数行検索|
|s|.を改行文字と一致するようにする。|
|u|unicodeパターンをユニコードのコードポイントの連続として扱う。|
|y|対象文字列で最後に見つかったマッチの位置から検索を開始する、先頭固定検索を使う。|

正規表現メモ

|表現|意味|
|---|---|
|.|任意の1文字|
|+|直前の文字が1回以上繰り返すパターン。条件にあう、最長の部分にマッチする。|
|*|直前の文字が0回以上繰り返すパターン。条件にあう、最長の部分にマッチする。|
|?|直前の文字が0または1個のパターン。条件にあう、最長の部分にマッチする。|
|+?|直前の文字が1回以上繰り返すパターン。条件にあう、最短の部分にマッチする。|
|*?|直前の文字が0回以上繰り返すパターン。条件にあう、最短の部分にマッチする。取り出す要素、というよりは、所定の文字(文字グループ)を除外するのに使う。|
|??|直前の文字が0個または1個のパターン。条件にあう、最短の部分にマッチする。?が最長一致に対して、こちらは最短一致。|
|直前の文字、または直後の文字のいずれかに一致。|
|\|直後の正規表現記号をエスケープする。正規表現記号の文字にマッチさせたい場合に使用する。|
|\[...]|角括弧に含まれるいずれかの1文字を表すパターン。|
|\[a-z]|a～zの文字|
|\[A-Z]|A～Zの文字|
|\[0-9]|0～9の文字|
|\[^...]|角括弧に含まれない1文字を表すパターン。|
|\(...)|文字列をグループ化する（らしい）。JSだとパターン抽出にも使われるので紛らわしい。|
|{n}|直前の文字の桁数を指定する。|
|{n,}|直前の文字の再衣装桁数を指定する。|
|{n,m}|直前の文字の最小桁数(n)と最大桁数(m)を指定する。条件にあう、最長の部分にマッチする。|
|{n,m}?|直前の文字の最小桁数(n)と最大桁数(m)を指定する。条件にあう、最短の部分にマッチする。|
|\t|タブ。|
|\r|CR(Carriage Return:0x0D)。|
|\n|LF(Line Feed:0x0A)。|
|\d|全ての数字|
|\D|全ての数字以外の文字。\[^0-9]に一致|
|\s|垂直タブ以外の全ての空白文字。[ \t\f\r\n]に一致。|
|\S|全ての非空白文字。\[^\s] に一致。|
|\w|アルファベット、アンダースコア、数字。\[a-zA-Z_0-9]に一致|
|\W|\wの否定。\[^\w]に一致。|
|^|行頭。|
|$|行末。|
|\<|単語の先頭|
|\>|単語の末尾|
|\b|単語の先頭か末尾。|
|\B|単語の先頭か末尾以外。\[^\b]に一致。|
|\A|ファイルの先頭。|
|\z|ファイルの末尾。|
|\G|直前の一致文字列の末尾。|

0:置換文字列全体
1,2,...:一致したパターン。

よく使うパターン

|一致させるパターン|正規表現|
|---|---|
|整数パターン|[+-]?\d+|
|整数パターン(正数のみ)|\+?\d+|
|実数パターン|[+-]?\d+\.?\d+|
|実数パターン%有無|[+-]?\d+\.?\d+|
      

## __プロパティ宣言__

オブジェクトXに新しいプロパティa,...を宣言する。

~~~javascript
  Object.defineProperties(X, {
    a : { get:function() { return hoge;} },
       // 以下必要な数定義する
  });
~~~

プロパティ用メンバ

|メンバ|型|説明|
|---|---|---|
|configurable|boolean|プロパティの変更を許可する場合にtrue。falseにすると再定義できない。|
|writable|boolean|代入演算子(=)で設定できる場合にtrue|
|get|function|プロパティ値を返すファンクション。|
|set|function|プロパティ値を設定するファンクション。set(value)になる。|


